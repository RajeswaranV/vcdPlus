{
    "collab_server" : "",
    "contents" : "#'  Given an input matrix, we can split it into smaller sub-matrix (min 2x2) and then find\n#'  the Chi-squared test for each sub-matrix. The smaller matrix can \"support\"  or \"oppose\"\n#'  (have a different conclusion at 95% confidence interaval) compared with the overall Chi-squared\n#'  test value of the full input matrix. We count the number of times each cell supports or\n#'  opposes the overall Chi-squared test. We also generate the possible list of sub-matrix.\n#' @param mat - matrix for which the sub-matrix is to be generated\n#' @param details - If this is set to TRUE, the the return value includes the full list of\n#' sub-matrix\n#' @details  This can be used as an outlier detection method as well as observing the individual\n#' cells within an IxJ table\n#' @return A of dataframes with\n#'  \\item{Hot.df}{  Dataframe with the difference between the supporting matrix and the opposing matrix}\n#'  \\item{Suport.df }{ Dataframe of the cell counts for support of table level Chi-sqaured }\n#'  \\item{Oppose.df }{ Dataframe of the cell counts for opposing of table level Chi-sqaured }\n#'  \\item{sub-matrix }{ list of sub-matrix - this is returned only if the details flag is set to TRUE }\n#' @family IxJ Inference methods\n#' @examples\n#' Example data - Archaeological finds discovered in Nevada, from Mosteller and Parunak (2006).\n#' Drills=c(2,\t10,\t4,\t2 )\n#' Pots= c(3,\t8,\t4,\t6)\n#' Grinding.Stones=c( 13, 5, 3, 9)\n#' Point.Fragments=c(20, 36, 19, 20)\n#' mat=rbind(Drills,Pots,Grinding.Stones,Point.Fragments)\n#' Local.Odds.Ratio(mat)\n#' @references\n#' [1] Mosteller F, Parunak A (2006)\n#' Identifying extreme cells in a sizable contingency table: Probabilistic and exploratory approaches.\n#' In: Hoaglin DC, Mosteller F, Tukey JW (eds) Exploring Data Tables, Trends, and Shapes,\n#' John Wiley & Sons, pp 189–224\n#' @export\nLocal.Odds.Ratio<-function(mat)\n{\n  if (missing(mat)) stop(\"'mat' is missing\")\n  if ((class(mat) != \"matrix\"))  stop(\"'mat' has to be a matrix with minimum 2x2\")\n  if ((dim(mat)[1] < 2) || (dim(mat)[2] <2 )) stop(\"Matrix has to be minimum of 2x2\")\n  \n  out.df = NULL\n  \n  Total.columns=ncol(mat)\n  Total.rows=nrow(mat)\n  Big.counter.mat=mat-mat\n  Index.mat=Big.counter.mat\n  \n  # Take cols first and then find the row elements for each col combination\n  # Column.combos=Total.columns-2\n  for(Column.iterator in 2:Total.columns){\n    #  print(Column.iterator)\n    Current.Column.Combo=combn(Total.columns,Column.iterator)\n    \n    # Now loop over the combinations of columns\n    # This loop below will generate the data for the various column combinations\n    # Using this we go over each row combination\n    for(Loop.col in 1:ncol(Current.Column.Combo)){\n      \n      Input.col.mat = mat[,c(Current.Column.Combo[,Loop.col])]\n      #print(Input.col.mat)\n      \n      # Now generating the row combinations for the given columns\n      for(Row.iterator in 2:Total.rows){\n        #  print(Row.iterator)\n        Current.Row.Combo=combn(Total.rows,Row.iterator)\n        for(Row.lowest.selection in 1:ncol(Current.Row.Combo)){\n          Useful.mat = Input.col.mat[c(Current.Row.Combo[,Row.lowest.selection]),]\n          #  print(Useful.mat)\n          Big.counter.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]=\n          Big.counter.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]+1\n          \n            Index.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]=\n            Index.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]+1\n          \n          if(dim(Useful.mat)[1]==2 & dim(Useful.mat)[2]==2){\n            # Only 2x2 matrix have been filtered. Within these 2x2 matrix we find the OR.\n            # Just doing a count of the cells taking only the 2x2 matrix.\n            Index.4.cells=which(Index.mat !=0, arr.ind = T)\n            \n            # Resetting the Index mat to zero's \n            Index.mat = Index.mat - Index.mat\n              \n # Only 2x2 matrix have been filtered. Within these 2x2 matrix we find the OR applying \n # 0.5 cc if there are zero's\n              \n              a=Useful.mat[1,1]\n              b=Useful.mat[1,2]\n              c=Useful.mat[2,1]\n              d=Useful.mat[2,2]\n              if(a==0 || b==0 || c==0 || d==0){\n              a.all=a+0.5\n              b.all=b+0.5\n              c.all=c+0.5\n              d.all=d+0.5\n              } else { \n                a.all=a\n                b.all=b\n                c.all=c\n                d.all=d\n                      }# End of adding cc\n              \n              ora.all  = (a.all*d.all  / b.all*c.all)\n              \n          \n          out.full =    data.frame(    Odds.Ratio=ora.all,\n                                       a=a.all,\n                                       b=b.all,\n                                       c=c.all,\n                                       d=d.all,\n                                       Index1RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\"),\n                                       Index2RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\"),\n                                       Index3RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\"),\n                                       Index4RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\"))\n          out.df = rbind(out.df, out.full)\n          \n          } # End of if condition checking for 2x2 matrix\n            \n        } # End of for loop for lowest Row selection\n        \n      } # End of for loop in Row.iterator for the current col combination\n      \n    } # End of for loop in Loop.col for the current col combination\n    \n  } #End of for-loop Column.iterator\n  \n  \n  # write.table(out.df,\"D:/Research/CDA/Testing/Full.out.csv\",append=TRUE,row.names=FALSE, col.names = FALSE, sep=\",\")\n  \n  \n  # We need to correct the chi-sq value by 1 to ensure we dont use the full matrix count\n  if(chisq.test(mat)$p.value < 0.05){\n    Positive.mat = Positive.mat-1\n    Support.mat = Positive.mat\n    Oppose.mat = Negetive.mat\n  } else { Negetive.mat= Negetive.mat-1\n  Support.mat = Negetive.mat\n  Oppose.mat = Positive.mat\n  } # End of chi-squared test correction to ensure that we dont take full matrix value\n  \n  Support.df=data.frame(Support=Support.mat)\n  Oppose.df=data.frame(Oppose=Oppose.mat)\n  Hot.mat= Support.mat-Oppose.mat\n  Hot.df = data.frame(Heatmap=Hot.mat)\n  \n  if(details){st.list =list(Hot.df,Support.df,Oppose.df, out.df) }\n  else {st.list=list(Hot.df,Support.df,Oppose.df)}\n  \n  return(st.list)\n} # End of function\n\n\n########################################\nlocal.odds.DM <- function(NI,NJ) {\n  # Produces the matrix C, needed for producing the vector of\n  # log local odds ratios of a NIxNJ table\n  # Used also in combination to Lang’s mph.fit (version 3.0)\n  # for fitting models directly on the local odds ratios.\n  # Assumes that the data are provided by rows.\n  loc<-c(1,-1);\n  a<-function(i){c(rep(0,(i-1)),loc,rep(0,NJ-i-1))}\n  CA1<-a(1); i<-2;\n  while(i<NJ) { CA1<-rbind(CA1,a(i)); i<-i+1}\n  CA1<-matrix(CA1,NJ-1); CA2<- -CA1;\n  zer<-rep(0,NJ*(NJ-1)); zer<-matrix(zer,NJ-1);\n  block0<- function(i) { # i goes up to NI-2\n    block<-zer; k<-2;\n    while (k<i+1) { block<-cbind(block,zer); k<-k+1}\n    return(block) }\n  Cblock<- function(i) { # i goes from 2 up to (NI-1)\n    if (NI-i-1>0) {\n      block<-cbind(block0(i-1),CA1,CA2,block0(NI-i-1))}\n    else {block<-cbind(block0(i-1),CA1,CA2)}\n    return(block) }\n  C<-cbind(CA1,CA2,block0(NI-2)); i<-2;\n  while(i<NI) {\n    C<-rbind(C,Cblock(i)); i<-i+1}\n  if (NI==2) {dim <- NI*NJ; C <- C[,1:dim]}\n  return(C)\n}",
    "created" : 1495809212129.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "3607692754",
    "id" : "C08B25DB",
    "lastKnownWriteTime" : 1495006189,
    "last_content_update" : 1495895897717,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled7"
    },
    "relative_order" : 19,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}