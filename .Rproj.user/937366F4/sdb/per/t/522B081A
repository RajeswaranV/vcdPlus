{
    "collab_server" : "",
    "contents" : "#' Given an input matrix, we can split it into smaller 2x2 sub-matrix and then find\n#'  the Nominal Odds Ratio  for each sub-matrix (subtable) keeping a reference row and column\n#'  which can be defined by the user. By default the last row and column is taken as the reference.\n#' @param mat - matrix for which the sub-matrix is to be generated.\n#' @param Reference.Row.ID - The row to be used as reference. By default, the last row is taken as the reference.\n#' @param Reference.Col.ID - The column to be used as reference. By default, the last column is taken as the reference.\n#' @details This can be used as input to models.\n#'   If any of the cells a,b,c or d is zero, a continuity correction of 0.5 is added\n#'   to all the cells and the odds ratio is calculated. For nominal classification\n#'   variables this set of basic 2x2 tables is defined in terms of a reference category,\n#'   usually the cell (I,J).\n#'   Then the 2x2 tables formed have in their upper diagonal cell the (i, j) cell of the initial table,\n#'   for i= 1 to I -1, j=1 to J-1 and in the lower diagonal cell always the reference cell (I,J). The\n#'   non-diagonal cells are the cells of the initial table that share one classification\n#'   variable index with each diagonal cell, i.e., they are the cells (i,J) and (I, j).\n#' @return A of dataframes with\n#'  \\item{Odds.Ratio}{  Odds Ratio of the 2x2 subtable}\n#'  \\item{a }{ The value of a taken from the input table}\n#'  \\item{b }{ The value of b taken from the input table }\n#'  \\item{c }{ The value of c taken from the input table }\n#'  \\item{d }{ The value of d taken from the input table }\n#'  \\item{Index1RC }{ Index reference from the input matrix for a (Row,Column) }\n#'  \\item{Index2RC }{ Index reference from the input matrix for b (Row,Column) }\n#'  \\item{Index3RC }{ Index reference from the input matrix for c (Row,Column) }\n#'  \\item{Index4RC }{ Index reference from the input matrix for d (Row,Column) }\n#' @family IxJ Inference methods\n#' @examples\n#'##  Here we use the default last column as the reference.\n#' mat=matrix(c(1:9), nrow=3, ncol=3)\n#' Nominal.Odds.Ratio(mat,Reference.Row.ID=3, Reference.Col.ID=3 ) # Same as Nominal.Odds.Ratio(mat)\n#'##  Now we change the reference row and column to 2\n#' Nominal.Odds.Ratio(mat, 2, 2)\n#' @references\n#' [1] Kateri, Maria.\n#' Contingency Table Analysis.\n#' Springer New York, 2014.\n#' @export\nNominal.Odds.Ratio<-function(mat,Reference.Row.ID=NULL, Reference.Col.ID=NULL )\n{\n  if (missing(mat)) stop(\"'mat' is missing\")\n  if ((class(mat) != \"matrix\"))  stop(\"'mat' has to be a matrix with minimum 2x2\")\n  if ((dim(mat)[1] < 2) || (dim(mat)[2] <2 )) stop(\"Matrix has to be minimum of 2x2\")\n  if (is.null(Reference.Row.ID)) { Reference.Row.ID = nrow(mat)}\n  if (is.null(Reference.Col.ID)) { Reference.Col.ID = ncol(mat)}\n  if (((class(Reference.Row.ID) != \"numeric\" & (class(Reference.Row.ID) != \"integer\")) ||\n       (class(Reference.Col.ID) != \"numeric\" & (class(Reference.Col.ID) != \"integer\"))  ||\n       Reference.Row.ID%%1!=0 ||\n       Reference.Col.ID%%1!=0 ))\n    stop(\"'Reference.Row.ID' and 'Reference.Col.ID' have to be an integer\")\n  if ( Reference.Row.ID > nrow(mat) ||\n       Reference.Row.ID < 1 )  stop(\"'Reference.Col.ID' has to be between 1 and max number of rows\")\n  if ((Reference.Col.ID) > ncol(mat) ||\n      (Reference.Col.ID) < 1)  stop(\"'Reference.Col.ID' has to be between 1 and max number of columns\")\n\n  if(is.null(Reference.Row.ID)){Reference.Row.ID=nrow(mat)}\n  if(is.null(Reference.Col.ID)){Reference.Col.ID=ncol(mat)}\n\n  out.df = NULL\n\n  Total.columns=ncol(mat)\n  Total.Rows=nrow(mat)\n  Index.mat=mat-mat\n\n  # Take cols first and then find the row elements for each col combination\n\n  Current.Column.Combo.row1=seq(from=1, to=Total.columns)\n  Current.Column.Combo.row2=rep(Reference.Col.ID,Total.columns)\n  Current.Column.Combo=rbind(Current.Column.Combo.row1,Current.Column.Combo.row2)\n\n\n  # Now loop over the combinations of columns\n  # This loop below will generate the data for the various column combinations\n  # Using this we go over each row combination\n\n  for(Loop.col in 1:ncol(Current.Column.Combo)){\n    if(Loop.col!=Reference.Col.ID){\n      Input.col.mat = mat[,c(Current.Column.Combo[,Loop.col])]\n      #print(Input.col.mat)\n\n      # Now generating the row combinations for the given columns\n      Current.Row.Combo.row1=seq(from=1,to=Total.Rows)\n      Current.Row.Combo.row2=rep(Reference.Row.ID,Total.Rows)\n      Current.Row.Combo=rbind(Current.Row.Combo.row1,Current.Row.Combo.row2)\n\n      for(Row.lowest.selection in 1:ncol(Current.Row.Combo)){\n        if(Row.lowest.selection!=Reference.Row.ID){\n          Useful.mat = Input.col.mat[c(Current.Row.Combo[,Row.lowest.selection]),]\n          #  print(Useful.mat)\n          #  Big.counter.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]=\n          #   Big.counter.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]+1\n\n          Index.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]=\n            Index.mat[c(Current.Row.Combo[,Row.lowest.selection]),c(Current.Column.Combo[,Loop.col])]+1\n          # Only 2x2 matrix have been filtered. Within these 2x2 matrix we find the OR.\n          # Just doing a count of the cells taking only the 2x2 matrix.\n          Index.4.cells=which(Index.mat !=0, arr.ind = T)\n\n          # Resetting the Index mat to zero's - we have the cell information in Index.4.cells\n          Index.mat = Index.mat - Index.mat\n\n          # Only 2x2 matrix have been filtered. Within these 2x2 matrix we find the OR applying\n          # 0.5 cc if there are zero's\n\n          a=Useful.mat[1,1]\n          b=Useful.mat[1,2]\n          c=Useful.mat[2,1]\n          d=Useful.mat[2,2]\n          if(a==0 || b==0 || c==0 || d==0){\n            a.all=a+0.5\n            b.all=b+0.5\n            c.all=c+0.5\n            d.all=d+0.5\n          } else {\n            a.all=a\n            b.all=b\n            c.all=c\n            d.all=d\n          }# End of adding cc\n\n          ora.all  = (a.all*d.all ) / (b.all*c.all)\n\n          RR.ID.Flag=0\n\n          if(Reference.Row.ID!=Total.Rows & Row.lowest.selection>Reference.Row.ID &\n             Reference.Col.ID!=Total.columns & Loop.col>Reference.Col.ID) {\n            Index1RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\")\n            Index2RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\")\n            Index3RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\")\n            Index4RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\")\n            RR.ID.Flag=1}\n\n          if(Reference.Row.ID!=Total.Rows & Row.lowest.selection>Reference.Row.ID & RR.ID.Flag<1)\n          {\n            Index1RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\")\n            Index2RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\")\n            Index3RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\")\n            Index4RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\")\n            RR.ID.Flag=1\n          } else {\n            if(RR.ID.Flag<1){\n              Index1RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\")\n              Index2RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\")\n              Index3RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\")\n              Index4RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\")\n            }\n          }\n\n          if(Reference.Col.ID!=Total.columns & Loop.col>Reference.Col.ID & RR.ID.Flag<1)\n          {\n            Index1RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\")\n            Index2RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\")\n            Index3RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\")\n            Index4RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\")\n          } else {\n            if(RR.ID.Flag<1){\n              Index1RC=paste(Index.4.cells[1,1],Index.4.cells[1,2],sep=\",\")\n              Index2RC=paste(Index.4.cells[3,1],Index.4.cells[3,2],sep=\",\")\n              Index3RC=paste(Index.4.cells[2,1],Index.4.cells[2,2],sep=\",\")\n              Index4RC=paste(Index.4.cells[4,1],Index.4.cells[4,2],sep=\",\")\n            }\n          }\n\n\n\n          out.full =    data.frame(    Odds.Ratio=ora.all,\n                                       a=a.all,\n                                       b=b.all,\n                                       c=c.all,\n                                       d=d.all,\n                                       Index1RC,\n                                       Index2RC,\n                                       Index3RC,\n                                       Index4RC)\n\n          out.df = rbind(out.df, out.full)\n\n        } # End of if checking for Row.lowest.selection!=Reference.Row.ID\n      } # End of for loop for lowest Row selection\n\n    } # End of if checking for Ref.Col!=Loop.col\n  } # End of for loop in Loop.col for the current col combination\n\n  return(out.df)\n} # End of function\n",
    "created" : 1501299673164.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2717504588",
    "id" : "522B081A",
    "lastKnownWriteTime" : 1501264462,
    "last_content_update" : 1501264462,
    "path" : "D:/Research/CDA/vcdPlus/R/600.Nominal-odds-ratio.R",
    "project_path" : "R/600.Nominal-odds-ratio.R",
    "properties" : {
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}